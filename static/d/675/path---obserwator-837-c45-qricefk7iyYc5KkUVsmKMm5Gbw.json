{"data":{"site":{"siteMetadata":{"title":"HLipinski devlog","author":"Hubert Lipinski"}},"markdownRemark":{"id":"0bc196f1-a622-541f-8e28-82a85d9bbf74","excerpt":"Obserwator pozwala na zdefiniowanie relacji pomiędzy obiektami, w której po zmianie stanu wybranego obiektu (Podmiotu) poinformowane zostają wszystkie obiekty…","html":"<p><strong>Obserwator</strong> pozwala na zdefiniowanie relacji pomiędzy obiektami, w której po zmianie stanu wybranego obiektu (Podmiotu) poinformowane zostają wszystkie obiekty powiązane (Obserwatorzy).</p>\n<p>Zaletą zastosowania tego wzorca jest to, że obiekty Podmiotu i Obserwatorów są ze sobą luźno powiązane: w każdej chwili można dodać lub usunąć obiekt obserwujący, bez wpływu na cały system.</p>\n<p>W JDK w pakiecie <em>java.io</em> został dostarczony szkielet (klasa <em>Observable</em>, interfejs <em>Observer</em>), który ułatwia implementację tego wzorca:</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d48723b331181128c3851e0359f4e302/90647/image1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 531px;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 45.38606403013182%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAAB+ElEQVQoz51SO4wSURQdRl01bmxstfFTIfUyYaMWhlCbmNhoQWuiFjYWaEMCgYIKiikIyCaQ0NEBBSF8wyf8CYRfAuEPCRAiYXafz/Nm2UQLLbzJZO7MOe+8e++53GKxoJ1Oh2YymZ/VavViv9/TXq/3ikNQSnk8LOXAebnZbM7S6bQYCATE4XD4fTabfVWpVNcZHolEZB7X7XalWq0mNRoNaT6f7yBA8/n8W4bpdLo7Wq32+CD4jWHT6ZRCjKV0t9v1BEG4yfBsNnsp2O/3aaVSoaiODgYDmYhL3jHM4XAcGY3GG4eL36Pyi9FotARlISHW63UMlx4xPJVKXQrGYrGPoVDog8vl+lKv1z9hBJ+bzeajQ8sK7hDxePzYZrMpPR7Pw2g0et9isShFUXxwhXu9Xu6fgZkq9Ho912q1eMyH/wtNYTKZrqFdPplM8uj0D57i9w8Icf8VqESNFk4MBsNzn88nlEolTTgcvscwvG/lcrkTt9utNpvNGqfTKcDlU4zoNs7dRVWndrtdsFqtGr/frw4Gg2qOECIbMZlM6Ha7vcrfHJx9glUhMIKOx2O6Wq1kHPlTzPoFy2GU7Dwcp2wFuXa7TUAg+EkgdI7VocVi8TUTTCQSjwuFwo9yucxWhWDvzpfLJcU/JVbrGZxn2yGx8xAjOEd+ATk1eEbo6YpIAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    ></span>\n    <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n        alt=\"Diagram 1\"\n        title=\"\"\n        src=\"/static/d48723b331181128c3851e0359f4e302/90647/image1.png\"\n        srcset=\"/static/d48723b331181128c3851e0359f4e302/cf440/image1.png 148w,\n/static/d48723b331181128c3851e0359f4e302/d2d38/image1.png 295w,\n/static/d48723b331181128c3851e0359f4e302/90647/image1.png 531w\"\n        sizes=\"(max-width: 531px) 100vw, 531px\"\n      />\n  </span>\n  </a></p>\n<p>Podmiot powinien dziedziczyć po klasie Observable, a obiekty Obserwatorów implementować Observer. Obiekty obserwujące powiadamiamy metodą <em>notifyObservers()</em>. Warto pamiętać, żeby przed powiadomieniem ustawić flagę, że obiekt rzeczywiście się zmienił, wywołując metodę <em>setChanged()</em>. Bez tej informacji, obiekty nie zostaną powiadomione:</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">notifyObservers</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>changed<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    arrLocal <span class=\"token operator\">=</span> obs<span class=\"token punctuation\">.</span><span class=\"token function\">toArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">clearChanged</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Aktualizacja może przebiegać w dwóch różnych trybach:</p>\n<ul>\n<li>Podmiot może wysyłać dane do wszystkich obiektów obserwujących,</li>\n<li>Podmiot może informować obiekty obserwujące o zmianie, po czym one same mogą pobrać niezbędne dane.</li>\n</ul>\n<p>Zaproponowany przez JDK szkielet posiada pewną wadę, o której warto pamiętać: komponent <em>Observable</em> jest klasą, a dodatkowo, część jej metod jest chroniona, dlatego oznaczanie Podmiotu tym sposobem wiąże się z koniecznością dziedziczenia. Przed skorzystaniem z tego szkieletu warto zastanowić się, czy pogodzić się z takim kontraktem, czy stworzyć właśny komponent <em>Observable</em> w postaci interfejsu.</p>","frontmatter":{"title":"Wzorzec Obserwator","date":"15-06-2019"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/obserwator/","previous":{"fields":{"slug":"/git-toolbox/"},"frontmatter":{"title":"Git toolbox"}},"next":{"fields":{"slug":"/equals-overriding/"},"frontmatter":{"title":"Equals method overriding"}}}}